---
title: "R Notebook"
output: html_notebook
---

Practical MLE Notes

## By Hand

```{r}
set.seed(2017)
p.parameter <- 0.8
sequence <- rbinom(10, 1, p.parameter)

likelihood <- function(sequence, p.parameter) {
  likelihood <- 1
  for (i in 1:length(sequence)) {
    if (sequence[i] == 1) {
      likelihood <- likelihood * p.parameter
    } else {
      likelihood <- likelihood * (1 - p.parameter)
    }
  }
  return(likelihood)
}
```

```{r}
possible.p <- seq(0, 1, by = 0.001)
qplot(
  possible.p,
  map_dbl(possible.p, function(p) {
    likelihood(sequence, p)
  }),
  geom = "line",
  main = "Likelihood as a Function of P",
  xlab = "P",
  ylab = "Likelihood"
)
```

For a single variable
```{r}
mle.results <- optimize(
  function(p) {
    likelihood(sequence, p)
  },
  interval = c(0, 1), # values of p must lie in the interval
  maximum = TRUE
)
mle.results
```


## Log-Likelihood

```{r}
log.likelihood <- function(sequence, p) {
  log.likelihood <- 0

  for (i in 1:length(sequence)) {
    if (sequence[i] == 1) {
      log.likelihood <- log.likelihood + log(p)
    } else {
      log.likelihood <- log.likelihood + log(1 - p)
    }
  }

  return(log.likelihood)
}
```

```{r}
log.likelihood2 <- function(sequence, p) {
  log.likelihood <- 0

  for (i in 1:length(sequence)) {
    if (sequence[i] == 1) {
      log.likelihood <- log.likelihood + log(p)
    } else {
      log.likelihood <- log.likelihood + log(1 - p)
    }
  }

  return(log.likelihood)
}
```

```{r}
sequence <- c(0, 1, 1, 1, 1, 1, 1, 0, 1, 0)
possible.p <- seq(0, 1, by = 0.001)
qplot(
  possible.p,
  sapply(possible.p, function(p) {
    log.likelihood(sequence, p)
  }),
  geom = "line",
  main = "Log Likelihood as a Function of P",
  xlab = "P",
  ylab = "Log Likelihood"
)
```

```{r}
mle.results_log <- optimize(
  function(p) {
    likelihood(sequence, p)
  },
  interval = c(0, 1), # values of p must lie in the interval
  maximum = TRUE
)
mle.results_log
```


## Poisson

```{r}
lprob_poisson <- function(lambda, x) {
  n <- length(x)
  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))
}

ll_poisson1 <- function(x) {
  n <- length(x)
  function(lambda) {
    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))
  }
}
```

```{r}
x1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)
lprob_poisson(c(10, 20, 30), x1)

ll1 <- ll_poisson1(x1)
```

Rather than trial and error, we can automate the process of finding the best value with `optimise()`. It will evaluate `ll1()` many times, using mathematical tricks to narrow in on the largest value as quickly as possible. The results tell us that the highest value is -30.27 which occurs when lambda = 32.1:

```{r}
optimise(ll1, c(0, 100), maximum = TRUE)
```

```{r}
optimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)
```


## DPLYR Approach

```{r}
set.seed(2017)

pois_10 <- data.frame(lambda_vals = 0:20) %>%
  mutate(likelihood = dpois(x = 10, lambda = lambda_vals))

# Get the MLE
pois_10 %>%
  filter(likelihood == max(likelihood))
```

```{r}
ggplot(pois_10, aes(x = lambda_vals, y = likelihood)) +
  geom_point() +
  geom_line()
```

### Log-Likelihood

```{r}
set.seed(2017)
pois_10_log <- pois_10 %>%
  mutate(log_likelihood = dpois(x = 10, lambda = lambda_vals, log = TRUE))

ggplot(pois_10_log, aes(x = lambda_vals, y = log_likelihood)) +
  geom_point()
```

## Maximum Likelihood by Grid Search

```{r}
set.seed(2017)

crossing(
  mu = seq(from = 10, to = 30, by = 0.1),
  sigma = seq(from = 0, to = 10, by = 0.1)
) %>%
  rowwise() %>%
  mutate(
    L = prod(dnorm(c(30, 20, 24, 27), mean = mu, sd = sigma))
  ) %>%
  arrange(desc(L))
```


### Log-Likelihood by Grid

```{r}
set.seed(2017)

crossing(
  mu = seq(from = 10, to = 30, by = 0.1),
  sigma = seq(from = 0, to = 10, by = 0.1)
) %>%
  rowwise() %>%
  mutate(
    log_L = sum(dnorm(c(30, 20, 24, 27), mean = mu, sd = sigma, log = TRUE))
  ) %>%
  arrange(desc(log_L))
```


MLE By Hand

`prod()` for likelihood, `sum()` for log-likelihood
Density functions don’t take kindly to a vector of data and a vector of parameters, we’ll use `rowwise()` to iterate over rows, but `ungroup()` after for other operations. 

Let’s try this for a random dataset that we generate from a Poisson distribution with a lambda of 10.

```{r}
set.seed(2017)
pois_data <- rpois(10, lambda = 10)

pois_mle <- data.frame(lambda_vals = 0:20) %>%
  rowwise() %>%
  mutate(log_likelihood = pois_likelihood(y = pois_data, lambda = lambda_vals)) %>%
  ungroup()
```

```{r}
# Plot the surface
pois_mle %>%
  ggplot(aes(x = lambda_vals, y = log_likelihood)) +
  geom_point(size = 2) +
  xlab("Lambda") +
  ylab("Log Likelihood") +
  theme_bw(base_size = 16) +
  geom_vline(aes(xintercept = which.max(log_likelihood), color = "red"), show.legend = FALSE)
```

Log-Likelihood
```{r}
pois_mle %>%
  filter(log_likelihood == max(log_likelihood))
```

```{r}
# https://biol607.github.io/lab/07_likelihood.html
```

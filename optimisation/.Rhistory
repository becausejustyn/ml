library(magrittr)  # to use piping %>%
library(ggplot2)   # for ploting
library(MASS)      # to calculate the peseudo-inverse of a matrix
library(caret)     # to center our data by subtracting its mean
library(reshape2)  # for data manipulation
load("data1.RData")
# All the variables below are matrices
X <- data1$X
Xval <- data1$Xval # This is cross-validation data
yval <- data1$yval # This shows which rows in Xval are anomalous
head(X)
X <- as.data.frame(X)
names(X) <- c("Latency (ms)", "Throughput (mb/s)")
XX <- melt(X)
XX %>% ggplot(aes(
x = value,
fill = variable,
color = variable
)) +
geom_density(alpha = 0.3) +
labs(
title = "Distibution of X"
)
Xval <- as.data.frame(Xval)
names(Xval) <- c("Latency (ms)", "Throughput (mb/s)")
XXval <- melt(Xval)
XXval %>% ggplot(aes(x = value, fill = variable, color = variable)) +
geom_density(alpha = 0.3) +
labs(title = "Distibution of Xval")
X %>% ggplot(aes(x = `Latency (ms)`, y = `Throughput (mb/s)`)) +
geom_point(color = "blue")
library(ggplot2)
library(data.table)
library(magrittr)
library(caret)
library(fields)
library(plot3D)
ex1data1 <- fread("ex1data1.txt",col.names=c("population","profit"))
head(ex1data1)
ex1data1 %>%
ggplot(aes(
x = population,
y = profit)) +
geom_point(color = "blue", size = 4, alpha = 0.5) +
labs(
x = "Population of City in 10,000s",
y = "Profit in $10,000s",
title = "Figure 1: Scatter plot of training data"
)  +
theme(plot.title = element_text(size = 16, colour = "red"))
X <- cbind(1, ex1data1$population)
y <- ex1data1$profit
head(X)
# The function below calcuates cost based on the equation given above.
computeCost <- function(X, y, theta) {
z <- ((X %*% theta) - y)^2
return(sum(z) / (2 * nrow(X)))
}
theta <- matrix(rep(0, ncol(X)))
round(computeCost(X, y, theta), 2)
gradientDescent <- function(X, y, theta, alpha, iters) {
gd <- list()
cost <- rep(0, iters)
for (k in 1:iters) {
z <- rep(0, ncol(X))
for (i in 1:ncol(X)) {
for (j in 1:nrow(X)) {
z[i] <- z[i] + (((X[j, ] %*% theta) - y[j]) * X[j, i])
}
}
theta <- theta - ((alpha / nrow(X)) * z)
cost[k] <- computeCost(X, y, theta)
}
gd$theta <- theta
gd$cost <- cost
gd
}
iterations <- 1500
alpha <- 0.01
theta <- matrix(rep(0, ncol(X)))
gradientDescent_results <- gradientDescent(X, y, theta, alpha, iterations)
theta <- gradientDescent_results$theta
theta
data.frame(Cost = gradientDescent_results$cost, Iterations = 1:iterations) %>%
ggplot(aes(x = Iterations, y = Cost)) +
geom_line(color = "blue") +
labs(title = "Cost as a function of number of iteration") +
theme(plot.title = element_text(size = 16, colour = "red"))
ex1data1 %>%
ggplot(aes(x = population, y = profit)) +
geom_point(color = "blue", size = 3, alpha = 0.5) +
labs(
x = "Population of City in 10,000s",
y = "Profit in $10,000s",
title = "Figure 1: Scatter plot of training data"
)  +
geom_abline(intercept = theta[1], slope = theta[2], col = "red", show.legend = TRUE) +
theme(plot.title = element_text(size = 16, colour = "red")) +
annotate("text", x = 12, y = 20, label = paste0("Profit = ", round(theta[1], 4), "+", round(theta[2], 4), " * Population"))
Intercept <- seq(from = -10, to = 10, length = 100)
Slope <- seq(from = -1, to = 4, length = 100)
# initialize cost values to a matrix of 0's
Cost <- matrix(0, length(Intercept), length(Slope))
for (i in 1:length(Intercept)) {
for (j in 1:length(Slope)) {
t <- c(Intercept[i], Slope[j])
Cost[i, j] <- computeCost(X, y, t)
}
}
persp3D(Intercept, Slope, Cost,
theta = -45, phi = 25, expand = 0.75, lighting = TRUE,
ticktype = "detailed", xlab = "Intercept", ylab = "Slope",
zlab = "", axes = TRUE, main = "Surface"
)
image.plot(Intercept, Slope, Cost, main = "Contour, showing minimum")
contour(Intercept, Slope, Cost, add = TRUE, n = 30, labels = "")
points(theta[1], theta[2], col = "red", pch = 4, lwd = 6)
theta2 <- solve((t(X) %*% X)) %*% t(X) %*% y
theta2
theta
iterations <- 15000
alpha <- 0.01
theta <- matrix(rep(0, ncol(X)))
gradientDescent_results <- gradientDescent(X, y, theta, alpha, iterations)
theta <- gradientDescent_results$theta
theta
my_lm <- train(profit ~ population, data = ex1data1, method = "lm")
my_lm$finalModel$coefficients
ex1data2 <- fread("ex1data2.txt", col.names = c("size", "bedrooms", "price"))
head(ex1data2)
ex1data2 <- as.data.frame(ex1data2)
class(ex1data2)
for (i in 1:(ncol(ex1data2) - 1)) {
ex1data2[, i] <- (ex1data2[, i] - mean(ex1data2[, i])) / sd(ex1data2[, i])
}
round(apply(ex1data2, 2, mean), 10)
apply(ex1data2, 2, sd)
X <- cbind(1, ex1data2$size, ex1data2$bedrooms)
y <- ex1data2$price
head(X)
iterations <- 6000
alpha <- 0.01
theta <- matrix(rep(0, ncol(X)))
gradientDescent_results <- gradientDescent(X, y, theta, alpha, iterations)
theta <- gradientDescent_results$theta
theta
theta2 <- solve((t(X) %*% X)) %*% t(X) %*% y
theta2
ex1data2 <- fread("ex1data2.txt", col.names = c("size", "bedrooms", "price"))
my_lm <- train(price ~ size + bedrooms,
data = ex1data2, method = "lm",
preProcess = c("center", "scale")
)
my_lm$finalModel$coefficients
